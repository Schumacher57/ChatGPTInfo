Привет!
Вот смотри, что я хочу, но у меня не получается.
Смотри, контекст такой язык программирования C#, платформа NetFramework, консольное приложение. У меня есть файл конфигурации app.config с таким содержимым (его я немного правил в части секции `MyParametr`): 
```XML
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <configSections>
        <sectionGroup name="applicationSettings" type="System.Configuration.ApplicationSettingsGroup, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" >
            <section name="ConfigSettingFrameWork.Properties.Settings" type="System.Configuration.ClientSettingsSection, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false" />
            <section name="asdasd" type="System.Configuration.ClientSettingsSection, System, Version=4.0.0.0" requirePermission="false" />
			<section name="MySection1" type="System.Configuration.ClientSettingsSection, System, Version=4.0.0.0" requirePermission="false" />
        </sectionGroup>
    </configSections>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.8" />
    </startup>
    <applicationSettings>
        <asdasd>
            <setting name="MyParametr" serializeAs="String">
                <value>123</value>
            </setting>
        </asdasd>
		<MySection1>
			<Value1>1</Value1>
			<Value2>2</Value2>
			<Value3>3</Value3>
		</MySection1>
    </applicationSettings>
</configuration>
```
Затем есть автоматически сгенерированный файл конфигурации `Settings.Designer.cs` со следующим содержимым:
```csharp
//------------------------------------------------------------------------------
// <auto-generated>
//     Этот код создан программой.
//     Исполняемая версия:4.0.30319.42000
//
//     Изменения в этом файле могут привести к неправильной работе и будут потеряны в случае
//     повторной генерации кода.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ConfigSettingFrameWork.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "17.1.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("123")]
        public string MyParametr {
            get {
                return ((string)(this["MyParametr"]));
            }
        }
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public MySection1 MySection1
        {
            get
            {
                return ((MySection1)(this["MySection1"]));
            }
        }
    }
}
```
Его я тоже немного сам правил в части `MySection1`.
А для считывания из файла настроек секции `MySection1` я специально создал класс: MySection1.cs, со следующим содержимым:
```csharp
using System.ComponentModel;
using System.Configuration;

namespace ConfigSettingFrameWork
{
    public class MySection1 : ConfigurationSection
    {
        [ConfigurationProperty("MySection1", IsDefaultCollection = false)]
        [ConfigurationCollection(typeof(MySectionCollection), AddItemName = "Value1")]
        public MySectionCollection Values
        {
            get { return (MySectionCollection)this["MySection1"]; }
            set { this["MySection1"] = value; }
        }
    }

    public class MySectionCollection : ConfigurationElementCollection
    {
        protected override ConfigurationElement CreateNewElement()
        {
            return new ValueElement();
        }

        protected override object GetElementKey(ConfigurationElement element)
        {
            return ((ValueElement)element).Value1;
        }
    }
    public class ValueElement : ConfigurationElement
    {
        [ConfigurationProperty("Value1", IsRequired = true)]
        public string Value1
        {
            get { return (string)this["Value1"]; }
            set { this["Value1"] = value; }
        }

        [ConfigurationProperty("Value2", IsRequired = true)]
        public string Value2
        {
            get { return (string)this["Value2"]; }
            set { this["Value2"] = value; }
        }

        [ConfigurationProperty("Value3", IsRequired = true)]
        public string Value3
        {
            get { return (string)this["Value3"]; }
            set { this["Value3"] = value; }
        }
    }

}
``` 
Затем я пытаюсь прочитать эти настройки в главном методе Main класса Program.cs, вот его содержимое:
```csharp
using System;
//using ConfigSetting.Config;
using System.Configuration;

namespace ConfigSettingFrameWork
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine($"result: {Properties.Settings.Default.MyParametr}");
            Console.WriteLine($"result: {Properties.Settings.Default.MySection1.Values}");

            //Console.ReadKey();
        }
    }
}
```
Вот почему-то Properties.Settings.Default.MyParametr возвращает: `123`, а свойство: Properties.Settings.Default.MySection1.Values возвращает null. Как мне в свойстве Properties.Settings.Default.MySection1.Values вернуть значения, а не null?